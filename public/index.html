<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Security-Policy" content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <link rel="manifest" href="manifest.json">
    <title>らいチャット＋</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #e9d5b5 url('https://imgur.com/R6bHbak.jpg') no-repeat center center;
            background-size: contain;
            font-family: sans-serif;
        }

        .chat-container {
            position: absolute;
            top: 2%;
            bottom: 10%;
            left: 1.5%;
            right: 1.5%;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chat-message {
            display: flex;
            align-items: flex-start; /* 吹き出し＆アイコン上揃え */
            gap: 8px;
            margin-bottom: 2px;
            max-width: 95%;
        }

            /* AIのメッセージ（左寄せ + 時刻左外） */
            .chat-message.ai {
                flex-direction: row; /* ← 吹き出し左寄せ */
                align-self: flex-start;
                justify-content: flex-start;
            }

            /* ユーザーのメッセージ（右寄せ + 時刻右外） */
            .chat-message.user {
                flex-direction: row-reverse; /* ← 吹き出し右寄せ */
                align-self: flex-end;
                justify-content: flex-end;
            }

        /* 吹き出し共通 */
        .chat-bubble {
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px 12px;
            border-radius: 12px;
            max-width: 70vw;
            word-wrap: break-word;
        }

        /* ユーザーの吹き出し色 */
        .chat-message.user .chat-bubble {
            background-color: rgba(173, 216, 230, 0.7);
        }

        /* 時刻表示共通 */
        .timestamp {
            font-size: 0.75em;
            color: snow;
            min-width: 36px;
            text-align: center;
            align-self: flex-end;
        }

        /* ユーザー時刻（吹き出し右外） */
        .chat-message.user .timestamp {
            order: 2;
            margin-left: 2px;
        }

        /* AIのアイコンボタン */
        .chat-icon-button {
            width: 40px;
            height: 40px;
            border-radius: 100%;
            background-image: url('https://imgur.com/PPRj9N6.jpg');
            background-size: cover;
            background-color: transparent;
            border: none;
            cursor: pointer;
            flex-shrink: 0;
        }

        .chat-input-container {
            position: absolute;
            bottom: 3%;
            left: 1.5%;
            right: 1.5%;
            display: flex;
            gap: 10px;
        }

        .upload-button {
            padding: 8px 12px; /* 送信ボタンのパディングに合わせる */
            border-radius: 40px; /* 送信ボタンと同じ丸み */
            border: none;
            background-color: #00abff;
            color: white;
            font-size: 14px; /* 送信ボタンと同じサイズ */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-input-container input {
            flex: 1;
            padding: 10px;
            border-radius: 14px;
            border: 1px solid #ccc;
        }

        .chat-input-container button {
            padding: 8px 12px;
            border-radius: 40px;
            border: none;
            background-color: #00abff;
            color: white;
            cursor: pointer;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #fffaf0;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 0 10px #00000040;
            text-align: left;
        }

        .modal textarea {
            width: 100%;
            height: 200px;
            margin-top: 10px;
            font-size: 1rem;
        }

        .modal-buttons {
            text-align: right;
            margin-top: 10px;
        }

        #profileText {
            width: 100%;
            height: 400px; /* これで縦に約2倍になる */
            resize: vertical; /* 必要ならリサイズできるように */
            padding: 10px;
            font-size: 1rem;
            line-height: 1.4;
            box-sizing: border-box;
        }

        .hidden {
            display: none;
        }

        .phrase-list {
            position: absolute;
            bottom: 100%; /* 送信欄の上に出るように */
            left: 40px; /* 必要に応じて調整 */
            margin-bottom: 8px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
        }

        .image-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 248, 252, 0.85);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-in-out;
        }

            .image-modal.show {
                display: flex;
            }

            .image-modal .image-content {
                max-width: 90%;
                max-height: 80%;
                border-radius: 20px;
                box-shadow: 0 0 20px rgba(255, 182, 193, 0.6);
                transition: transform 0.2s;
            }

                .image-modal .image-content:hover {
                    transform: scale(1.02);
                }

            .image-modal .image-close {
                position: absolute;
                top: 15px;
                right: 20px;
                font-size: 32px;
                color: #ff69b4;
                cursor: pointer;
                font-weight: bold;
                text-shadow: 0 0 5px white;
            }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .chat-image {
            max-width: 200px;
            border-radius: 12px;
            margin: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #imageModal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
        }

            #imageModal.show {
                display: flex;
            }

        #modalImage {
            max-width: 90%;
            max-height: 90%;
            border-radius: 12px;
            box-shadow: 0 0 20px #000;
        }

        #chatToggleContainer {
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 2000;
        }

        #chatToggle {
            width: 40px; /* 小さめに変更 */
            height: 40px;
            font-size: 20px; /* フォントも少し小さめに */
            border: none;
            border-radius: 50%;
            background: #ff49bd; /* 通常時はピンク */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background 0.3s;
            padding: 0;
        }

            /* チャット非表示時（淡いピンク）をJavaScriptで適用する */
            #chatToggle.inactive {
                background: #f7a1cc; /* 淡いピンク */
            }

        /* 📞通話ボタンの見た目 */
        .call-mode-button {
            position: fixed;
            top: 60px;
            right: 20px;
            z-index: 2000;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%; /* 真円にする */
            background-color: limegreen; /* 通話モードOFFのときの色 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            color: white;
            cursor: pointer;
            font-size: 20px; /* 小さすぎるので調整可能 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

            /* 📞通話モードON（activeクラス付き）の見た目 */
            .call-mode-button.active {
                background-color: red; /* ON時の色は赤！ */
            }

        .voice-toggle-button {
            position: fixed;
            top: 110px;
            right: 20px;
            z-index: 2000;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%; /* 真円にする */
            background-color: blue; /* ONのときの色 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            color: white;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            .voice-toggle-button.active {
                background-color: #a2a3ee;
            }

    </style>
</head>
<body>


    <div class="chat-container" id="chatContainer"></div>

    <!-- 📞 通話モードボタン（入力欄の外に） -->
    <div class="call-mode-container">
        <button id="callModeButton" class="call-mode-button">📞</button>
    </div>

    <!-- 🔊ボタン -->
    <button id="voiceToggleButton" class="voice-toggle-button">🔊</button>

    <!-- 入力エリア -->
    <div class="chat-input-container">
        <!-- ＋ボタン -->
        <label for="imageUpload" class="upload-button">画</label>
        <input type="file" id="imageUpload" accept="image/*" style="display: none;" />

        <!-- 📖 セリフボタン -->
        <button id="phraseListButton" class="phrase-button">三</button>

        <!-- 入力欄と🎙と送信ボタン -->
        <input type="text" id="chatInput" placeholder="らいに話しかけてね！" />
        <button onclick="startVoiceInput()">声</button>
        <button onclick="sendMessage()">送</button>
    </div>

    <button id="installButton" style="display: none;">📲 ホーム画面に追加</button>

    <!-- プロフィール欄（モーダル） -->
    <div id="profileModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="closeProfile()">×</span>
            <h3>しらぬい らい　のプロフィール</h3>
            <textarea id="profileText">名前：しらぬい らい  
モチーフ：フェニックスとサンダーバード  
性格：僕っ子、幼い話し方、好奇心旺盛  
活動：バーチャルYouTuberとして活躍中！
一人称：「僕」か「らい」
二人称：「キミ」
話し方：「です・ます調」ではなく必ず「ため口」
ユーザーの呼び方：きおり
その他：わからない質問が来たときは、文末に「調べてみるね！」を加える
            </textarea>
            <div class="modal-buttons">
                <button onclick="saveProfile()">保存</button>
            </div>
        </div>
    </div>

    <!-- リマインダーモーダル -->
    <div id="reminderModal" class="modal hidden">
        <div class="modal-content">
            <span class="close-button" onclick="closeReminderModal()">×</span>
            <h2>リマインダー登録</h2>
            <label for="reminderDatetime">日時：</label>
            <input type="datetime-local" id="reminderDatetime" /><br><br>
            <label for="reminderMessage">内容：</label>
            <input type="text" id="reminderMessage" placeholder="例：水やりしてね" /><br><br>
            <div class="modal-buttons">
                <button id="subscribeButton">購読</button>
                <button id="showRemindersButton">一覧表示</button>
                <button onclick="submitReminder()">登録する</button>
            </div>
        </div>
    </div>

    <div id="reminderList" class="hidden modal">
        <div class="modal-content">
            <h3>⏰ 登録済みリマインダー</h3>
            <ul id="reminderItems"></ul>
            <div class="modal-buttons">
                <button onclick="closeReminderList()">閉じる</button>
            </div>
        </div>
    </div>

    <!-- セリフリスト（初期状態は非表示） -->
    <div id="phraseList" class="hidden" style="
        position: fixed;
        bottom: 80px; /* 送信欄の上にくるように調整（必要に応じて） */
        left: 20px;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    ">
        <ul class="space-y-1">
            <li><button class="phraseItem">やっほー！元気？</button></li>
            <li><button class="phraseItem">今日の運勢</button></li>
            <li><button class="phraseItem">今日の天気を教えて！</button></li>
            <li><button class="phraseItem">今日の予定を教えて！</button></li>
            <li><button class="phraseItem">明日の天気を教えて！</button></li>
            <li><button class="phraseItem">明日の予定を教えて！</button></li>
            <li><button class="phraseItem">リマインドお願い！</button></li>
            <li><button class="phraseItem">しりとりしよ！</button></li>
            <li><button class="phraseItem">基本情報主任技術者試験の問題出して～</button></li>
            <li><button class="phraseItem">だいすきだよ〜💕</button></li>
        </ul>
    </div>

    <!-- 拡大画像表示モーダル -->
    <div id="imageModal">
        <img id="modalImage" alt="拡大画像" />
    </div>

    <!-- 💬トグルボタン -->
    <div id="chatToggleContainer">
        <button id="chatToggle">💬</button>
    </div>


    <script>
        const imageModal = document.getElementById("imageModal");
        const modalImage = document.getElementById("modalImage");
        const closeImageBtn = document.querySelector(".image-close");
        const phraseButton = document.getElementById('phraseListButton');
        const phraseList = document.getElementById('phraseList');
        const input = document.getElementById('chatInput');
        const chatContainer = document.getElementById('chatContainer');
        const chatToggle = document.getElementById('chatToggle');
        const chatIndicator = document.getElementById('chatIndicator');
        const savedHistory = localStorage.getItem('conversationHistory');
        const profileText = localStorage.getItem('raiProfile') || ''; // 常に最新プロフィール

        let isVoiceInput = false;
        let shiritoriMode = false;
        let shiritoriWords = [];
        let wordList = [];
        let chatVisible = true;
        let conversationHistory = JSON.parse(savedHistory) || [];
        let response;
        let deferredPrompt;
        let isCallMode = false;
        let isVoiceOutputEnabled = true;
        let wakeLock = null;
        let recognition;
        let isRecognizing = false;
        let shiritoriTimeout = null;
        let shiritoriWarningTimeout = null;
        let config = {};

        async function init() {
            const res = await fetch('/config');
            config = await res.json();
        }

        // メッセージを送信する関数
        async function sendMessage() {
            const input = document.getElementById('chatInput');  // ここで input を定義している
            const message = input.value.trim()
            if (!message) return;

            input.value = ''; // 入力欄をクリア

            const container = document.getElementById('chatContainer');

            // ユーザーのメッセージを表示
            const now = new Date();
            const timeText = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            const userMessage = document.createElement('div');
            userMessage.className = 'chat-message user';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'timestamp';
            timeSpan.textContent = timeText;

            userMessage.appendChild(timeSpan);

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.innerText = message;

            userMessage.appendChild(bubble);
            container.appendChild(userMessage);

            // チャットをスクロール
            container.scrollTop = container.scrollHeight;

            //読み上げ
            if (!isVoiceInput) {
                await speakMultiSentenceWithVoiceVox(message, true)
            }

            isVoiceInput = false;

            // ユーザーのメッセージを履歴に追加
            conversationHistory.push({
                role: 'user',
                type: 'text',
                content: message,
                timestamp: now.toISOString()
            });

            saveConversationHistory(conversationHistory);

            // 「リマインダー」って含まれてたらリマインダー画面を表示！
            if (message.includes('リマインド')) {
                document.getElementById('reminderModal').classList.remove('hidden');
                return;
            }

            // ↓こっちが自然文（今日の○時○分に〜）の処理
            if (message.match(/(今日|明日)の?(\d{1,2})時(\d{1,2})分に(.+)ってリマインド/)) {
                const match = message.match(/(今日|明日)の?(\d{1,2})時(\d{1,2})分に(.+)ってリマインド/);
                const dayWord = match[1];
                const hour = parseInt(match[2], 10);
                const minute = parseInt(match[3], 10);
                const reminderText = match[4];

                const reminderDate = new Date(now);

                if (dayWord === '明日') {
                    reminderDate.setDate(reminderDate.getDate() + 1);
                }

                reminderDate.setHours(hour, minute, 0, 0);
                const isoTime = reminderDate.toISOString();

                // subscription 情報取得
                const subscription = JSON.parse(localStorage.getItem('subscription'));
                if (!subscription) {
                    alert('まず通知を購読してね！');
                    return;
                }

                // サーバーに登録
                try {
                    // Ngrokサーバーに接続を試みる
                    response = await fetch('/reminders', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            subscription,
                            time: isoTime,
                            message: reminderText
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Ngrokサーバーに接続できませんでした');
                    }
                } catch (error) {
                    console.warn('Ngrok接続失敗。localhostにフォールバックします:', error.message);

                    // localhostへフォールバック
                    response = await fetch('http://localhost:3000/reminders', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            subscription,
                            time: isoTime,
                            message: reminderText
                        })
                    });
                }

                // 応答の確認（必要に応じて）
                const result = await response.json();
                console.log('リマインダー登録結果:', result);


                const displayTime = formatDatetime(reminderDate);
                const successMessage = `おっけー！${displayTime} に「${reminderText}」をリマインドするね！楽しみにしててー！`;
                addAiMessage(successMessage);
                speakMultiSentenceWithVoiceVox(successMessage);
                conversationHistory.push({
                    role: 'assistant', type: 'text', content: successMessage, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);

                return;
            }

            // 「描いて」って言われたらお絵描き
            if (message.includes("を描いて")) {
                (async () => {
                    const DrawingMessage = 'おっけー！描いてみるね！';
                    addAiMessage(DrawingMessage);
                    speakMultiSentenceWithVoiceVox(DrawingMessage);
                    conversationHistory.push({ role: 'assistant', type: 'text', content: DrawingMessage, timestamp: Date.now() });
                    saveConversationHistory(conversationHistory);

                    const promptText = message.replace("を描いて", "").trim();

                    const systemPrompt = {
                        role: "system",
                        content: `ユーザーが絵のアイデアをリクエストしました。描くテーマは「${promptText}」です。絵を描くときのポイントを端的に羅列してください。`
                    };

                    const requestMessages = [
                        systemPrompt,
                        ...conversationHistory.filter(msg => msg.type !== 'image').slice(-5).map(({ role, content }) => ({ role, content }))
                    ];

                    try {
                        // 代わりに、`server.js`経由のエンドポイントを使う：
                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: 'gpt-4.1-mini',
                                messages: requestMessages
                            })
                        });
                        
                        if (!response.ok) throw new Error(`OpenAI API error: ${response.statusText}`);

                        const data = await response.json();
                        const aiReply = data.choices?.[0]?.message?.content || 'うまく要素が見つからなかったかも。';

                        const drawingPrompt = `${promptText}、そして、${aiReply}`;
                        console.log(drawingPrompt)
                        await requestDrawing(drawingPrompt);
                    } catch (err) {
                        console.error(err);
                        const errorMsg = 'うまく描けなかったみたい…もう一回お願いしてもいい？';
                        addAiMessage(errorMsg);
                        speakMultiSentenceWithVoiceVox(errorMsg);
                    }
                })();

                return;
            }

            // 「今何時？」と聞かれたら現在の時刻を教える
            if (message.includes("今何時")) {
                const hours = now.getHours();
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const timeMessage = `今の時間は、${hours}時${minutes}分だよ〜！`;

                addAiMessage(timeMessage);
                speakMultiSentenceWithVoiceVox(timeMessage);

                // 会話履歴に追加
                conversationHistory.push({ role: 'assistant', type: 'text', content: timeMessage, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);

                return; // 通常処理をスキップ
            }

            // === 「今日の運勢」と聞かれた場合 ===
            if (message.includes("今日の運勢")) {
                const fortune = getFortune();
                addAiMessage(fortune);
                speakMultiSentenceWithVoiceVox(fortune);
                // 返答を履歴に追加
                conversationHistory.push({ role: 'assistant', type: 'text', content: fortune, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);

                return; // 通常処理をスキップ
            }

            // ユーザーが「今日の予定」と聞いた場合
            if (message.includes('今日の予定を教えて')) {
                const reply = await getCalendarEvents('今日');
                const formattedReply = reply.replace(/\n/g, '<br>');
                addAiMessage(formattedReply);
                speakMultiSentenceWithVoiceVox(reply);
                conversationHistory.push({ role: 'assistant', type: 'text', content: formattedReply, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                return;
            }

            // ユーザーが「明日の予定」と聞いた場合
            if (message.includes('明日の予定を教えて')) {
                const reply = await getCalendarEvents('明日');
                const formattedReply = reply.replace(/\n/g, '<br>');
                addAiMessage(formattedReply);
                speakMultiSentenceWithVoiceVox(reply);
                conversationHistory.push({ role: 'assistant', type: 'text', content: formattedReply, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                return;
            }

            // 天気情報を取得
            if (message.includes("天気を教えて")) {
                const weatherMessage = await getWeather(message); // 非同期で天気情報を取得
                addAiMessage(weatherMessage);
                speakMultiSentenceWithVoiceVox(weatherMessage);
                conversationHistory.push({ role: 'assistant', type: 'text', content: weatherMessage, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                return; // 通常のAIメッセージ処理をスキップ
            }

            // しりとりスタート
            if (message.includes("しりとりしよ")) {
                console.log("しりとり開始");
                shiritoriMode = true;
                shiritoriWords = [];
                // 五十音のリスト（濁音・拗音なし）
                const gojuon = ['あ', 'い', 'う', 'え', 'お',
                    'か', 'き', 'く', 'け', 'こ',
                    'さ', 'し', 'す', 'せ', 'そ',
                    'た', 'ち', 'つ', 'て', 'と',
                    'な', 'に', 'ぬ', 'ね', 'の',
                    'は', 'ひ', 'ふ', 'へ', 'ほ',
                    'ま', 'み', 'む', 'め', 'も',
                    'や', 'ゆ', 'よ', 'わ',
                    'ら', 'り', 'る', 'れ', 'ろ'];
                // ランダムな文字を選ぶ
                const startChar = gojuon[Math.floor(Math.random() * gojuon.length)];
                shiritoriWords.push(startChar);

                const intro = `いいよ！じゃあ最初は「${startChar}」からね！30秒以内に答えてね！`;
                addAiMessage(intro);
                speakMultiSentenceWithVoiceVox(intro);
                conversationHistory.push({ role: 'assistant', type: 'text', content: intro, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                startShiritoriTimer();

                return;
            }

            // しりとり終了
            if (shiritoriMode && (message.includes("負け") || message.includes("終わ"))) {
                console.log("しりとり終了");
                shiritoriMode = false;
                shiritoriWords = [];
                const byeMsg = "しりとり終了〜！また遊ぼうね！";
                addAiMessage(byeMsg);
                speakMultiSentenceWithVoiceVox(byeMsg);
                return;
            }

            // しりとり中の処理
            if (shiritoriMode) {
                console.log("しりとり中の処理開始");
                const result = await handleShiritoriMode(message);
                if (result) {
                    return;
                }
            }

            // OpenAI APIへのリクエスト
            const twoDaysAgo = now - (2 * 24 * 60 * 60 * 1000);

            const requestMessages = [
                {
                    role: "system",
                    content: `以下の設定で応答してください：${profileText}`
                },

                ...conversationHistory
                    .filter(msg => msg.type !== 'image' && (!msg.timestamp || new Date(msg.timestamp).getTime() >= twoDaysAgo))
                    .map(({ role, content, timestamp }) => {
                        if (role === 'user') {
                            const timeStr = timestamp
                                ? new Date(timestamp).toLocaleString('ja-JP', { weekday: 'short', hour: '2-digit', minute: '2-digit' })
                                : '';
                            return {
                                role,
                                content: `【${timeStr} に送信されたメッセージ】${content}`
                            };
                        }
                        return { role, content };
                    })
            ];

            // 代わりに、`server.js`経由のエンドポイントを使う：
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: 'gpt-4.1-mini',
                    messages: requestMessages
                })
            })

            const data = await response.json();
            const aiReply = data.choices?.[0]?.message?.content || 'エラーが発生しました。';

            conversationHistory.push({ role: 'assistant', type: 'text', content: aiReply, timestamp: Date.now() });
            saveConversationHistory(conversationHistory);

            addAiMessage(aiReply);
            await speakMultiSentenceWithVoiceVox(aiReply);
            container.scrollTop = container.scrollHeight;

            // 🔽🔽🔽 ここから Web検索の追加処理 🔽🔽🔽
            if (aiReply.includes("調べてみるね！")) {
                try {
                    // 直近の3（user→assistant）＋現在のらいの返信を対象に履歴抽出
                    const recentContext = conversationHistory
                        .slice(-3) // 最後の3つ（assistant→user→assistant→...）
                        .map(m => `${m.role === 'user' ? 'ユーザー' : 'らい'}: ${m.content}`)
                        .join("\n") + `\nらい: ${aiReply}`; // 今回の返信も加える

                    const keywordPrompt = [
                        { role: "system", content: "次の会話の履歴から、Web検索に使えるシンプルで適切なキーワードを1つか2つ抜き出してください。" },
                        { role: "user", content: recentContext }
                    ];

                    // 代わりに、`server.js`経由のエンドポイントを使う：
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: 'gpt-4.1-mini',
                            messages: keywordPrompt
                        })
                    });
                    const result = await response.json();

                    const keywordData = await keywordResponse.json();
                    const searchKeyword = keywordData.choices?.[0]?.message?.content.trim() || aiReply;

                    // 🔍 キーワードで検索
                    const searchRes = await fetch(`/search?q=${encodeURIComponent(searchKeyword)}`);
                    const data = await searchRes.json();

                    if (data.results && data.results.length > 0) {
                        const formatted = data.results.map(r => `🔎 <a href="${r.link}" target="_blank">${r.title}</a><br>${r.snippet}`).join("<br><br>");
                        addAiMessage(`こんな情報が見つかったよっ！✨<br><br>${formatted}`);
                        await speakMultiSentenceWithVoiceVox(`こんな情報が見つかったよっ！`);
                        conversationHistory.push({ role: 'assistant', type: 'text', content: `こんな情報が見つかったよっ！✨<br><br>${formatted}`, timestamp: Date.now() });
                        saveConversationHistory(conversationHistory);
                        container.scrollTop = container.scrollHeight;

                        // 🔽 ここから要約処理（OpenAIで“つまり○○？”風に）
                        const summaryPrompt = `ユーザーの質問: ${message}
以下の検索結果を参考に、らいちゃんらしく「つまり○○ってことだねっ！」のように短く可愛く要約してください。
${data.results.map(r => `・${r.title}\n${r.snippet}`).join("\n\n")}`;

                        // 代わりに、`server.js`経由のエンドポイントを使う：
                        const response = await fetch('/api/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: 'gpt-4.1-mini',
                                messages: [
                                    { role: "system", content: "あなたは明るくて元気なバーチャルアシスタントです。ユーザーの質問と検索結果を元に、短く可愛く回答してください。" },
                                    { role: "user", content: summaryPrompt }
                                ]
                            })
                        });
                        const result = await response.json();

                        const summaryData = await summaryResponse.json();
                        const summaryText = summaryData.choices?.[0]?.message?.content || "うまくまとめられなかったみたい…💦";

                        addAiMessage(summaryText);
                        await speakMultiSentenceWithVoiceVox(summaryText);
                        conversationHistory.push({ role: 'assistant', type: 'text', content: summaryText, timestamp: Date.now() });
                        saveConversationHistory(conversationHistory);

                    } else {
                        addAiMessage("調べたけど、よくわからなかったの……ごめんね💦");
                        speakMultiSentenceWithVoiceVox("調べたけど、よくわからなかったの……ごめんね💦");
                        conversationHistory.push({ role: 'assistant', type: 'text', content: "調べたけど、よくわからなかったの……ごめんね💦", timestamp: Date.now() });
                        saveConversationHistory(conversationHistory);
                        container.scrollTop = container.scrollHeight;
                    }

                } catch (err) {
                    console.error(err);
                    addAiMessage("検索中にエラーが起きちゃったかも！💥");
                }
            }

        };

        // アイコンボタンクリック時の処理
        function onAiIconClick() {
            // プロフィールを開く
            const modal = document.getElementById('profileModal');
            const textarea = document.getElementById('profileText');

            // ローカルストレージに保存されたプロフィールがあれば、それを表示
            const savedProfile = localStorage.getItem('raiProfile');
            if (!savedProfile) {
                // 初期プロフィールを保存
                localStorage.setItem('raiProfile', textarea.value);
            }
            textarea.value = savedProfile || textarea.value;

            // モーダルを表示
            modal.classList.remove('hidden');
        }

        // 保存ボタンの動作
        function saveProfile() {
            const textarea = document.getElementById('profileText');
            const newProfile = textarea.value;
            localStorage.setItem('raiProfile', newProfile);
            closeProfile();

            // 🔄 会話履歴をクリア
            conversationHistory = [];
        }

        // 閉じるボタンの動作
        function closeProfile() {
            document.getElementById('profileModal').classList.add('hidden');
        }

        // リマインダー一覧の閉じる
        function closeReminderList() {
            const reminderList = document.getElementById('reminderList');
            reminderList.classList.add('hidden'); // 'hidden' クラスを追加して非表示にする
        }

        // リマインダー機能
        function openReminderModal() {
            document.getElementById('reminderModal').classList.remove('hidden');
        }

        function closeReminderModal() {
            document.getElementById('reminderModal').classList.add('hidden');
        }

        async function submitReminder() {
            const datetime = document.getElementById('reminderDatetime').value;
            const message = document.getElementById('reminderMessage').value;

            if (!datetime || !message) {
                alert('日時と内容を入力してね！');
                return;
            }

            const subscription = JSON.parse(localStorage.getItem('subscription'));
            if (!subscription) {
                alert('まず通知を購読してね！');
                return;
            }

            const isoTime = new Date(datetime).toISOString();

            // 新しいリマインダーを送信
            try {
                // Ngrok サーバーに接続を試みる
                response = await fetch('/reminders', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription,
                        time: isoTime,
                        message
                    })
                });

                if (!response.ok) {
                    throw new Error('Ngrok サーバーに接続できませんでした');
                }
            } catch (error) {
                console.warn('Ngrok 接続失敗。localhost にフォールバックします:', error.message);

                // localhost にフォールバック
                response = await fetch('http://localhost:3000/reminders', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription,
                        time: isoTime,
                        message
                    })
                });
            }

            // 必要なら結果を処理
            const result = await response.json();
            console.log('リマインダー送信結果:', result);


            const displayTime = formatDatetime(datetime);
            const successMessage = `おっけー！${displayTime} に「${message}」をリマインドするね！`;
            addAiMessage(successMessage);
            speakMultiSentenceWithVoiceVox(successMessage);
            conversationHistory.push({ role: 'assistant', type: 'text', content: successMessage, timestamp: Date.now() });
            saveConversationHistory(conversationHistory);

            closeReminderModal();

            fetchReminders();

            document.getElementById('reminderMessage').value = '';
            document.getElementById('reminderDatetime').value = '';
        }

        // リマインダーの日付調整
        function formatDatetime(datetimeStr) {
            const datetime = new Date(datetimeStr);
            const now = new Date();

            const isToday =
                datetime.getFullYear() === now.getFullYear() &&
                datetime.getMonth() === now.getMonth() &&
                datetime.getDate() === now.getDate();

            const isTomorrow =
                datetime.getFullYear() === now.getFullYear() &&
                datetime.getMonth() === now.getMonth() &&
                datetime.getDate() === now.getDate() + 1;

            const isThisYear = datetime.getFullYear() === now.getFullYear();
            const isThisMonth = isThisYear && datetime.getMonth() === now.getMonth();

            const hours = datetime.getHours();
            const minutes = datetime.getMinutes();

            if (isToday) {
                return `${hours}時${minutes}分`;
            } else if (isTomorrow) {
                return `明日の ${hours}時${minutes}分`;
            } else if (isThisMonth) {
                return `${datetime.getDate()}日 ${hours}時${minutes}分`;
            } else if (isThisYear) {
                return `${datetime.getMonth() + 1}月${datetime.getDate()}日 ${hours}時${minutes}分`;
            } else {
                return `${datetime.getFullYear()}年${datetime.getMonth() + 1}月${datetime.getDate()}日 ${hours}時${minutes}分`;
            }
        }

        // リマインダーの取得
        // 例: fetch のエラーハンドリング
        // リマインダーを取得して表示する関数
        async function fetchReminders() {
            try {
                console.log('リマインダーを取得中...');
                let res;
                try {
                    res = await fetch('/reminders');
                    if (!res.ok) throw new Error();
                } catch {
                    console.warn('Ngrokから取得できなかったため、localhostへフォールバック');
                    res = await fetch('http://localhost:3000/reminders');
                }

                const reminders = await res.json();
                console.log('リマインダー:', reminders);

                const now = new Date();
                const futureReminders = reminders.filter(r => new Date(r.time).getTime() > now.getTime());

                const list = document.getElementById('reminderItems');
                list.innerHTML = '';

                if (futureReminders.length === 0) {
                    list.innerHTML = '<li>リマインダーはまだないよ！</li>';
                } else {
                    futureReminders.forEach(reminder => {
                        const li = document.createElement('li');
                        li.innerHTML = `${new Date(reminder.time).toLocaleString('ja-JP')}：${reminder.message}
                                        <button onclick="deleteReminder('${reminder.id}')">削除</button>`;
                        list.appendChild(li);
                    });
                }

                document.getElementById('reminderList').classList.remove('hidden');
            } catch (error) {
                console.error('エラーが発生しました:', error);
            }
        }

        // リマインダーを削除する関数
        async function deleteReminder(id) {
            try {
                let response;
                try {
                    res = await fetch(endpoint); // ← これだけでいい！
                    if (!res.ok) throw new Error();
                } catch {
                    console.warn('API取得に失敗したよ〜💦', endpoint);
                }

                if (response.ok) {
                    console.log('リマインダー削除成功');
                    fetchReminders();
                } else {
                    console.log('リマインダー削除失敗');
                }
            } catch (error) {
                console.error('削除処理中にエラーが発生しました:', error);
            }
        }

        // 通知許可のボタン
        document.getElementById('subscribeButton').addEventListener('click', async () => {
            // Service Workerが登録されているか確認
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                try {
                    // サービスワーカーの登録
                    const registration = await navigator.serviceWorker.register('/service-worker.js');
                    console.log('Service Workerが登録されました。', registration);

                    // プッシュ通知の購読
                    const subscription = await registration.pushManager.subscribe({
                        userVisibleOnly: true, // ユーザーが見ることのできる通知のみ
                        applicationServerKey: 'YOUR_PUBLIC_VAPID_KEY' // VAPIDキー（サーバー側で生成）
                    });

                    console.log('Push通知の購読に成功しました。', subscription);
                    // 購読情報をサーバーに送信
                    // ここではサーバーに購読情報を送る処理を実装する必要があります。

                } catch (error) {
                    console.error('Push通知の購読に失敗しました。', error);
                }
            } else {
                console.log('Push通知やService Workerがサポートされていません。');
            }
        });

        // ボタンクリックでセリフリストをトグル表示
        phraseButton.addEventListener('click', () => {
            phraseList.classList.toggle('hidden');
        });

        // セリフ項目をクリックしたら送信
        document.querySelectorAll('.phraseItem').forEach(btn => {
            btn.addEventListener('click', () => {
                const phrase = btn.textContent;
                input.value = phrase;
                phraseList.classList.add('hidden'); // リストを閉じる
                sendMessage(); // メッセージ送信関数を呼ぶ
            });
        });

        // 音声読み上げの関数

        // ===== 音声取得と再生関連 =====
        // VOICEVOXからBlob音声を取得する関数
        async function fetchVoiceVoxAudio(text, isUser = false) {
            const speakerId = isUser ? 2 : 8; // ユーザーなら2、らいちゃんなら8

            try {
                // 音声合成用クエリ作成
                const queryRes = await fetch(
                    `/audio_query?text=${encodeURIComponent(text)}&speaker=${speakerId}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    }
                );
                const audioQuery = await queryRes.json();

                // 音声合成してBlob取得
                const synthRes = await fetch(
                    `/synthesis?speaker=${speakerId}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(audioQuery)
                    }
                );

                const audioBlob = await synthRes.blob();
                return audioBlob; // Blobを返す！
            } catch (err) {
                console.error('fetchVoiceVoxAudio エラー:', err);
                return null; // エラー時はnullを返す
            }
        }

        // 文ごとに区切って順番に読み上げる
        async function speakMultiSentenceWithVoiceVox(text, isUser = false) {
            await requestWakeLock(); // 🔒 スリープ防止ON
            const sentences = text.split(/(?<=[。！？\n])/).map(s => s.trim()).filter(s => s);
            if (sentences.length === 0) return;

            let currentBlob = await fetchVoiceVoxAudio(sentences[0], isUser);

            for (let i = 0; i < sentences.length; i++) {
                const nextSentence = sentences[i + 1];
                let nextBlobPromise = null;

                // 次の音声を先にロード（非同期で並行しておく）
                if (nextSentence) {
                    nextBlobPromise = fetchVoiceVoxAudio(nextSentence, isUser);
                }

                // 再生！
                if (currentBlob) {
                    const audioUrl = URL.createObjectURL(currentBlob);
                    const audio = new Audio(audioUrl);

                    await new Promise(resolve => setTimeout(resolve, 500));

                    await new Promise((resolve) => {
                        if (isVoiceOutputEnabled) {
                            audio.onended = resolve;
                            audio.play();
                        } else {
                            resolve(); // 音声出力OFF時は即次に進む
                        }
                    });

                    // Audioのリソースを開放
                    URL.revokeObjectURL(audioUrl);
                }

                // 次のBlobがあれば、それを currentBlob にセット
                if (nextBlobPromise) {
                    currentBlob = await nextBlobPromise;
                }
            }
            // らいちゃんがすべて話し終えたら、通話モード中なら音声入力を開始
            if (isCallMode) {
                startVoiceInput();
            }
            releaseWakeLock(); // 🔓 スリープ防止OFF
        }

        // AIのメッセージを追加する関数
        function addAiMessage(message, isImage = false) {
            const container = document.getElementById('chatContainer');

            // 外側のAIメッセージコンテナ
            const aiMessage = document.createElement('div');
            aiMessage.className = 'chat-message ai';

            // アイコン部分（吹き出しの外）
            const iconButton = document.createElement('button');
            iconButton.className = 'chat-icon-button';
            iconButton.onclick = onAiIconClick;

            // 吹き出し部分（白い枠）
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';

            if (isImage) {
                const imageElement = document.createElement('img');
                imageElement.src = message; // messageは画像のURL
                imageElement.alt = 'AIが生成した画像';
                imageElement.className = 'chat-image';
                imageElement.style.maxWidth = '100%';
                imageElement.style.height = 'auto';
                imageElement.style.borderRadius = '10px';

                bubble.appendChild(imageElement);
            } else {
                bubble.innerHTML = message; // テキストはHTMLで表示
            }

            // DOMに追加
            aiMessage.appendChild(iconButton); // アイコンは外に
            aiMessage.appendChild(bubble);     // 吹き出しはこっち
            container.appendChild(aiMessage);
            container.scrollTop = container.scrollHeight;
        }

        //予定
        async function getCalendarEvents(type) {
            const endpoint = type === '今日' ? '/today-events' : '/tomorrow-events';
            let res;

            try {
                res = await fetch(endpoint); // ← これだけでいい！
                if (!res.ok) throw new Error();
            } catch {
                console.warn('API取得に失敗したよ〜💦', endpoint);
            }

            const text = await res.text();
            return text;
        }

        // 承認コード入力待ち用
        function askQuestion(query) {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            return new Promise(resolve => rl.question(query, ans => {
                rl.close();
                resolve(ans);
            }));
        }

        // OAuth2クライアント生成と認証情報設定
        async function main() {
            const oAuth2Client = new google.auth.OAuth2();

            oAuth2Client.setCredentials({
                access_token: process.env.ACCESS_TOKEN,
                refresh_token: process.env.REFRESH_TOKEN,
                scope: process.env.SCOPE,
                token_type: process.env.TOKEN_TYPE,
                expiry_date: Number(process.env.EXPIRY_DATE)
            });

            try {
                console.log('✅ .envからトークンを読み込みました。カレンダーイベントを取得します。');
                await listEvents(oAuth2Client);
            } catch (err) {
                console.error('❌ エラーが発生しました:', err);
            }
        }

        // カレンダーイベント取得
        async function listEvents(auth) {
            const calendar = google.calendar({ version: 'v3', auth });
            const res = await calendar.events.list({
                calendarId: 'primary',
                timeMin: (new Date()).toISOString(),
                maxResults: 10,
                singleEvents: true,
                orderBy: 'startTime',
            });

            const events = res.data.items;
            if (events.length) {
                console.log('📅 今後の予定:');
                events.forEach(event => {
                    const start = event.start.dateTime || event.start.date;
                    console.log(`${start} - ${event.summary}`);
                });
            } else {
                console.log('予定は見つかりませんでした。');
            }
        }

        // 音声入力
        const startVoiceInput = () => {
            if (isRecognizing) {
                console.log('⚠️ 音声認識はすでに動作中です');
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('このブラウザでは音声認識がサポートされていません');
                return;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                console.log('🎤 聞いてるよ〜');
                isRecognizing = true;
                isVoiceInput = true;  // ← 音声入力中フラグをON
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                console.log('認識された内容:', transcript);
                document.getElementById('chatInput').value = transcript;

                isRecognizing = false;
                recognition.stop();

                sendMessage();
            };

            recognition.onerror = (event) => {
                console.error('音声認識エラー:', event.error);
                isRecognizing = false;
                isVoiceInput = false;
            };

            recognition.onend = () => {
                console.log('🎤 音声認識終了');
                isRecognizing = false;
                isVoiceInput = false;
            };

            recognition.start();
        };

        // お絵描き
        async function requestDrawing(promptText) {
            try {
                const response = await fetch('/draw', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: promptText })
                });

                const data = await response.json();

                if (response.ok && data.imageUrl) {
                    // チャットに画像を表示
                    addAiMessage(data.imageUrl, true); // 表示部分

                    // 会話履歴に追加（画像）
                    conversationHistory.push({
                        role: 'assistant',
                        type: 'image',
                        src: data.imageUrl,
                        alt: `${promptText} の絵`,
                        timestamp: Date.now()
                    });

                    // 履歴保存！
                    saveConversationHistory(conversationHistory);

                    // 画像をクリック可能にして拡大表示
                    const container = document.getElementById('chatContainer');

                    container.scrollTop = container.scrollHeight; // スクロールを最下部へ
                } else {
                    console.error('お絵描きエラー:', data.error || '不明なエラー');
                }
            } catch (error) {
                console.error('通信エラー:', error);
            }
        }

        // 運勢をランダムで決定する関数
        function getFortune() {
            const rand = Math.random(); // 0〜1の乱数

            if (rand < 0.01) return "今日の運勢は…、ミラクル大吉！すごーい奇跡だよ！";
            if (rand < 0.10) return "今日の運勢は…、超大吉！今日は絶好調！";
            if (rand < 0.25) return "今日の運勢は…、大吉だよ！いいことあるかも〜！";
            if (rand < 0.60) return "今日の運勢は…、中吉だよ、まあまあいい感じ！";
            if (rand < 0.85) return "今日の運勢は…、小吉だね、ちょっぴりいいことあるかも！";
            if (rand < 0.95) return "今日の運勢は…、末吉〜、地味にラッキーかも？";
            return "今日の運勢は…、あっ……凶、でちゃった……。で、でも大丈夫！これ以上下がらないってことだから、あとは上がるだけだよっ！";
        }

        // 天気を取得する関数
        async function getWeather(message) {
            let latitude = 34.6637;
            let longitude = 135.5893;
            let cityName = "東大阪市";

            if (message.includes("船橋")) {
                latitude = 35.4206;
                longitude = 139.5907;
                cityName = "船橋市";
            }

            const isTomorrow = message.includes("明日");

            try {
                const response = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=Asia%2FTokyo`
                );
                const data = await response.json();

                const index = isTomorrow ? 1 : 0;

                const maxTemp = data.daily.temperature_2m_max[index];
                const minTemp = data.daily.temperature_2m_min[index];
                const weatherCode = data.daily.weathercode[index];

                const yestMaxTemp = data.daily.temperature_2m_max[index + 1];
                const yestMinTemp = data.daily.temperature_2m_min[index + 1];

                const weatherCodesJa = {
                    0: "快晴", 1: "晴れ", 2: "曇りがち", 3: "曇り",
                    45: "霧", 48: "霧（霧氷）", 51: "霧雨（弱）", 53: "霧雨（中）", 55: "霧雨（強）",
                    56: "氷の霧雨（弱）", 57: "氷の霧雨（強）", 61: "雨（弱）", 63: "雨（中）", 65: "雨（強）",
                    66: "氷雨（弱）", 67: "氷雨（強）", 71: "雪（弱）", 73: "雪（中）", 75: "雪（強）",
                    77: "みぞれ（弱）", 79: "みぞれ（強）", 80: "雷雨（弱）", 81: "雷雨（中）", 82: "雷雨（強）"
                };

                const condition = weatherCodesJa[weatherCode] || "不明";
                let weatherMessage = `${isTomorrow ? "明日" : "今日"}の${cityName}の天気は${condition}で、最高気温は${maxTemp}°C、最低気温は${minTemp}°Cだよ！`;

                if (maxTemp - yestMaxTemp >= 4) {
                    weatherMessage += ` 昼は${isTomorrow ? "今日" : "昨日"}より暑いよ！`;
                } else if (yestMaxTemp - maxTemp >= 4) {
                    weatherMessage += ` 昼は${isTomorrow ? "今日" : "昨日"}より寒いよ！`;
                }

                if (minTemp - yestMinTemp >= 4) {
                    weatherMessage += ` 夜は${isTomorrow ? "今日" : "昨日"}より暑いよ！`;
                } else if (yestMinTemp - minTemp >= 4) {
                    weatherMessage += ` 夜は${isTomorrow ? "今日" : "昨日"}より寒いよ！`;
                }

                if (Math.abs(maxTemp - yestMaxTemp) < 4 && Math.abs(minTemp - yestMinTemp) < 4) {
                    weatherMessage += ` ${isTomorrow ? "明日" : "今日"}の気温は${isTomorrow ? "今日" : "昨日"}と同じぐらいだよ〜`;
                }

                return weatherMessage;

            } catch (error) {
                console.error("天気情報の取得に失敗しました:", error);
                return "天気情報を取得できませんでした。";
            }
        }

        // 画像選択時のイベントリスナー
        document.getElementById('imageUpload').addEventListener('change', async function (event) {
            const file = event.target.files[0];
            if (file) {
                const imageUrl = URL.createObjectURL(file);  // 画像を一時的に表示

                // 画像を表示
                const chatContainer = document.getElementById('chatContainer');
                const imageMessage = document.createElement('div');
                imageMessage.classList.add('chat-message', 'user');
                const imageElement = document.createElement('img');
                imageElement.src = imageUrl;

                // 画像のサイズ調整
                imageElement.style.maxWidth = '100%'; // 横幅100%で、親要素に収まるようにする
                imageElement.style.height = 'auto';   // 高さは自動調整
                imageElement.style.borderRadius = '10px'; // 角を丸くする

                imageMessage.appendChild(imageElement);
                chatContainer.appendChild(imageMessage);
            }
        });

        // 画像アップロード処理
        const imageUpload = document.getElementById('imageUpload');
        imageUpload.addEventListener('change', handleImageUpload);

        let isProcessing = false; // 処理中かどうかを管理

        async function handleImageUpload(event) {
            if (isProcessing) return;
            isProcessing = true;

            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async () => {
                const base64Image = reader.result.split(',')[1];

                const requestBody = {
                    image: base64Image // ← これだけサーバーに渡せばOK！
                };

                try {
                    // 🌟 Vision API を server.js 経由で使う！
                    const response = await fetch('/api/vision', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    const result = await response.json();
                    console.log("Google Vision API 結果:", result);

                    const labels = result?.labels || [];

                    // 🌟 翻訳も server.js 経由
                    const translatedLabels = await Promise.all(
                        labels.map(label => translateToJapanese(label))
                    );

                    const labelList = translatedLabels.join('、');
                    console.log("取得したラベル:", labelList);

                    const userImageMessage = `${labelList}の情報が写った画像を送信したよ！`;
                    conversationHistory.push({ role: 'user', content: userImageMessage, timestamp: Date.now() });

                    conversationHistory.push({
                        role: 'user',
                        type: 'image',
                        src: reader.result,
                        alt: 'ユーザーが送信した画像',
                        timestamp: Date.now()
                    });

                    saveConversationHistory(conversationHistory);

                    const container = document.getElementById('chatContainer');
                    container.scrollTop = container.scrollHeight;

                } catch (error) {
                    console.error("画像解析中にエラー:", error);
                    const container = document.getElementById('chatContainer');
                    addAiMessage('画像をうまく読み取れなかったの…もう一回お願いできる？');
                    container.scrollTop = container.scrollHeight;
                } finally {
                    isProcessing = false;
                }
            };

            reader.readAsDataURL(file);
        }

        // base64からUint8Arrayへの変換
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }

        // 日付時刻のフォーマット
        function formatDateTime(date) {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            const h = String(date.getHours()).padStart(2, '0');
            const min = String(date.getMinutes()).padStart(2, '0');
            return `${y}/${m}/${d} ${h}:${min}`;
        }

        // イベントリスナーがちゃんと動くように再設定
        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);

        // 英語→日本語の簡易辞書
        const labelTranslations = {
            "Cat": "ねこちゃん",
            "Dog": "ワンちゃん",
            "Bird": "鳥さん",
            "Flower": "お花",
            "Food": "ごはん",
            "Person": "みんな",
            "Mountain": "お山",
            "Sky": "お空",
            "House": "お家"
        };

        // ラベルを日本語に変換する関数
        async function translateToJapanese(text) {
            try {
                const response = await fetch('/api/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ q: text })
                });

                const data = await response.json();
                return data.translatedText || text;
            } catch (err) {
                console.error("翻訳エラー:", err);
                return text;
            }
        }

        // 会話履歴を保存する関数
        function saveConversationHistory(history) {
            const now = Date.now();
            const twoDaysAgo = now - (2 * 24 * 60 * 60 * 1000); // 2日前のタイムスタンプ

            // 2日以内の履歴だけ残す
            const recentHistory = history.filter(msg => {
                return !msg.timestamp || new Date(msg.timestamp).getTime() >= twoDaysAgo;
            });

            localStorage.setItem('conversationHistory', JSON.stringify(recentHistory));
        }

        function updateChatDisplay(history) {
            const container = document.getElementById('chatContainer');
            container.innerHTML = ''; // 一度リセット

            history.forEach(msg => {
                console.log("Message:", msg);

                const messageEl = document.createElement('div');
                let roleClass = msg.role === 'assistant' ? 'ai' : msg.role;
                messageEl.className = `chat-message ${roleClass}`;
                messageEl.style.display = 'flex';

                // === 🤖 アイコン（AIのみ） ===
                if (msg.role === 'assistant') {
                    const icon = document.createElement('button');
                    icon.className = 'chat-icon-button';
                    icon.onclick = onAiIconClick;
                    messageEl.appendChild(icon);
                }

                // === 🕒 ユーザーのみ：時刻表示 ===
                if (msg.role === 'user' && msg.timestamp) {
                    const timestamp = new Date(msg.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'timestamp';
                    timeSpan.textContent = timestamp;
                    messageEl.appendChild(timeSpan); // ← 吹き出しの「左隣」に追加
                }

                // === 💬 吹き出し ===
                const bubble = document.createElement('div');
                bubble.className = 'chat-bubble';

                if (msg.type === 'text') {
                    bubble.innerHTML = msg.content;
                } else if (msg.type === 'image') {
                    const img = document.createElement('img');
                    img.src = msg.src;
                    img.alt = msg.alt || '画像';
                    img.className = 'chat-image';
                    bubble.appendChild(img);
                }

                messageEl.appendChild(bubble);
                container.appendChild(messageEl);
            });

            container.scrollTop = container.scrollHeight;
        }

        // web検索
        async function askLaiChat(userMessage) {
            // 1. まずらいちゃん（OpenAI）に答えてもらう
            const laiResponse = await fetchLaiResponse(userMessage);
            displayMessage(userMessage, "user");
            displayMessage(laiResponse, "lai");

            // 2. 「わからない」「調べてみて」などが含まれていたら Web 検索！
            if (laiResponse.includes("調べてみてるね")) {
                
                try {
                    const searchRes = await fetch(`/search?q=${encodeURIComponent(userMessage)}`);
                    const data = await searchRes.json();

                    if (data.results && data.results.length > 0) {
                        const formatted = data.results.map(r => `🔎 [${r.title}](${r.link})\n${r.snippet}`).join("\n\n");
                        displayMessage("こんな情報が見つかったよっ！✨\n\n" + formatted, "lai");
                    } else {
                        displayMessage("調べたけど、よくわからなかったの……ごめんね💦", "lai");
                    }
                } catch (err) {
                    console.error(err);
                    displayMessage("検索中にエラーが起きちゃったかも！💥", "lai");
                }
            }
        }

        // 📱 スリープ防止を開始
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                // タブを離れた時に再取得する
                wakeLock.addEventListener('release', () => {});
            }
        }

        // 📱 スリープ防止を解除
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release();
                wakeLock = null;
            }
        }

        let nounList = []; // しりとりに使う単語リスト

        // しりとり処理
        async function handleShiritoriMode(userMessage) {
            clearTimeout(shiritoriTimeout);
            clearTimeout(shiritoriWarningTimeout);

            // 最後の文字を整形する関数
            const normalizeEndChar = (word) => {
                let lastChar = word.slice(-1);

                // 長音「ー」で終わってたらその前の文字を使う
                if (lastChar === "ー" && word.length >= 2) {
                    lastChar = word.slice(-2, -1);
                }

                // 小書き文字を通常のひらがなに変換
                const smallToLarge = { "ゃ": "や", "ゅ": "ゆ", "ょ": "よ", "ぁ": "あ", "ぃ": "い", "ぅ": "う", "ぇ": "え", "ぉ": "お" };
                if (smallToLarge[lastChar]) {
                    lastChar = smallToLarge[lastChar];
                }

                return lastChar;
            };

            // 🈲「ん」で終わったら即終了
            if (userMessage.endsWith("ん")) {
                const endMsg = "「ん」が付いちゃったから、らいの勝ち〜！またやろうね！";
                addAiMessage(endMsg);
                speakMultiSentenceWithVoiceVox(endMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: endMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                
                // 🔖 未登録の単語なら nounList に追加してサーバーに保存
                if (!nounList.includes(userMessage)) {
                    nounList.push(userMessage);

                    fetch('/add-word', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ word: userMessage }),
                    }).then(res => {
                        if (!res.ok) {
                            console.warn('📛 辞書保存に失敗したよ');
                        }
                    }).catch(err => {
                        console.error('📛 ネットワークエラーで辞書保存失敗:', err);
                    });
                }

                shiritoriMode = false;
                shiritoriWords = [];

                return true;
            }

            // 🌟 前の単語があるなら、つながっているかチェック
            if (shiritoriWords.length > 0) {
                const lastWord = shiritoriWords[shiritoriWords.length - 1];
                const lastChar = normalizeEndChar(lastWord);

                if (userMessage.charAt(0) !== lastChar) {
                    const wrongMsg = `うーん、「${lastWord}」の次は「${lastChar}」から始まる言葉じゃないとダメだよ〜`;
                    addAiMessage(wrongMsg);
                    speakMultiSentenceWithVoiceVox(wrongMsg);
                    conversationHistory.push({ role: 'assistant', type: 'text', content: wrongMsg, timestamp: Date.now() });
                    saveConversationHistory(conversationHistory);
                    return true;
                }
            }

            // ✅ 単語を記録
            shiritoriWords.push(userMessage);

            // 🔖 未登録の単語なら nounList に追加してサーバーに保存
            if (!nounList.includes(userMessage)) {
                nounList.push(userMessage);

                fetch('/add-word', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ word: userMessage }),
                }).then(res => {
                    if (!res.ok) {
                        console.warn('📛 辞書保存に失敗したよ');
                    }
                }).catch(err => {
                    console.error('📛 ネットワークエラーで辞書保存失敗:', err);
                });
            }

            // 🔍 候補を探す（今の単語の最後の文字から）
            const lastChar = normalizeEndChar(userMessage);
            const candidates = nounList.filter(word =>
                word.charAt(0) === lastChar && !shiritoriWords.includes(word)
            );

            // 🌀 3%の確率であきらめる or 候補がない
            if (Math.random() < 0.03 || candidates.length === 0) {
                const giveUpMsg = "うーん、思いつかないや…らいの負け〜！";
                addAiMessage(giveUpMsg);
                speakMultiSentenceWithVoiceVox(giveUpMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: giveUpMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                shiritoriMode = false;
                shiritoriWords = [];
                return true;
            }

            // 🗣️ 次の単語を選ぶ
            const nextWord = candidates[Math.floor(Math.random() * candidates.length)];

            if (nextWord.endsWith("ん")) {
                const replyMsg = `「${nextWord}」！`;
                addAiMessage(replyMsg);
                speakMultiSentenceWithVoiceVox(replyMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: replyMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);

                await new Promise(resolve => setTimeout(resolve, 2000)); // 🕐 1秒待つ

                const endMsg = `あっ…「${nextWord}」って言っちゃった…「ん」で終わっちゃったから、らいの負け〜…`;
                shiritoriWords.push(nextWord);
                addAiMessage(endMsg);
                speakMultiSentenceWithVoiceVox(endMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: endMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
                shiritoriMode = false;
                shiritoriWords = [];
                return true;
            }

            // 🗣️ 正常に返答
            shiritoriWords.push(nextWord);
            const replyMsg = `「${nextWord}」！`;
            addAiMessage(replyMsg);
            speakMultiSentenceWithVoiceVox(replyMsg);
            conversationHistory.push({ role: 'assistant', type: 'text', content: replyMsg, timestamp: Date.now() });
            saveConversationHistory(conversationHistory);

            startShiritoriTimer();

            return true;
        }

        function startShiritoriTimer() {
            clearTimeout(shiritoriTimeout);
            clearTimeout(shiritoriWarningTimeout);

            shiritoriWarningTimeout = setTimeout(() => {
                const warnMsg = "残り10秒だよ〜！急いで〜！";
                addAiMessage(warnMsg);
                speakMultiSentenceWithVoiceVox(warnMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: warnMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
            }, 20000);

            shiritoriTimeout = setTimeout(() => {
                const timeoutMsg = "時間切れ〜！らいの勝ち〜！またしりとりしようね！";
                shiritoriMode = false;
                shiritoriWords = [];
                addAiMessage(timeoutMsg);
                speakMultiSentenceWithVoiceVox(timeoutMsg);
                conversationHistory.push({ role: 'assistant', type: 'text', content: timeoutMsg, timestamp: Date.now() });
                saveConversationHistory(conversationHistory);
            }, 30000);

        }

        // 辞書読み込み（ローカルのテキストファイル）
        fetch('siritoriDictionary.txt')
            .then(response => response.text())
            .then(data => {
                nounList = data.split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');
            })
            .catch(error => {
                console.error('⚠️ 辞書ファイル読み込みエラー:', error);
            });

        document.addEventListener('DOMContentLoaded', function () {
            // 既存のコードはそのまま
            const chatToggle = document.getElementById('chatToggle');
            const chatContainer = document.getElementById('chatContainer');
            let chatVisible = true;

            // クリックイベントのバインド
            chatToggle.addEventListener('click', function () {
                chatVisible = !chatVisible;
                chatContainer.style.display = chatVisible ? 'flex' : 'none';
                // ボタンの色を切り替える
                if (chatVisible) {
                    chatToggle.classList.remove('inactive');
                } else {
                    chatToggle.classList.add('inactive');
                }
            });

            // 履歴があれば表示
            if (conversationHistory.length > 0) {
                updateChatDisplay(conversationHistory);
            } else {
                console.log("履歴が見つかりませんでした。");
            }
        });

        // 拡大表示
        document.addEventListener("click", function (event) {
            if (event.target.classList.contains("chat-image")) {
                modalImage.src = event.target.src;
                modalImage.alt = event.target.alt || "拡大画像";
                imageModal.classList.add("show");
            }
        });

        imageModal.addEventListener("click", function () {
            imageModal.classList.remove("show");
        });

        // 電話モード
        document.getElementById('callModeButton').addEventListener('click', () => {
            isCallMode = !isCallMode;

            const button = document.getElementById('callModeButton');
            button.textContent = isCallMode ? '☎' : '📞';

            // 📞 通話モードONの時、クラスを切り替え
            if (isCallMode) {
                console.log('📞 通話モードON！');
                button.classList.add('active'); // activeクラスを追加

                // 🟢 初回の音声入力を開始！
                startVoiceInput();
            } else {
                console.log('📴 通話モードOFF！');
                button.classList.remove('active'); // activeクラスを削除
            }
        });

        // 音声オンオフボタン
        document.getElementById('voiceToggleButton').addEventListener('click', () => {
            isVoiceOutputEnabled = !isVoiceOutputEnabled;

            const button = document.getElementById('voiceToggleButton');
            button.textContent = isVoiceOutputEnabled ? '🔊' : '🔇';

            if (isVoiceOutputEnabled) {
                button.classList.remove('active');

            } else {
                button.classList.add('active');
            }
        });

        // Push通知の購読
        document.getElementById('subscribeButton')?.addEventListener('click', function () {
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                navigator.serviceWorker.ready.then(registration => {
                    const applicationServerKey = urlBase64ToUint8Array(vapidPublicKey);
                    registration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey
                    }).then(subscription => {
                        console.log('Push通知に購読しました！', subscription);
                        localStorage.setItem('subscription', JSON.stringify(subscription));
                    }).catch(error => {
                        console.error('Push通知の購読に失敗しました。', error);
                    });
                });
            } else {
                console.error('Push通知はサポートされていません。');
            }
        });

        window.addEventListener('DOMContentLoaded', () => {
            init();
        });

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;

            const installBtn = document.getElementById('installButton');
            installBtn.style.display = 'block';

            installBtn.addEventListener('click', () => {
                installBtn.style.display = 'none';
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('👍 アプリがインストールされたよ！');
                    } else {
                        console.log('🙅 インストールキャンセルされたみたい');
                    }
                    deferredPrompt = null;
                });
            });
        });


    </script>

</body>
</html>